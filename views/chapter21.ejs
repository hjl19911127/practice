<!DOCTYPE html>
<html>
<head>
	<title><%= title %></title>
	<link rel="stylesheet" href="/highlight/styles/tomorrow-night.css">
	<link rel="stylesheet" href="/stylesheets/style.css">
	<script src='/highlight/highlight.pack.js'></script>
	<script src='/javascripts/EventUtil.js'></script>
	<style>
	.lower-alpha{
		padding-top: 20px;
		padding-bottom: 20px;
		border-radius: 5px;
		font-size: 14px;
		line-height: 2;
		background: #d9edf7;
		list-style-type: lower-alpha;
	}
	</style>
</head>
<body>
	<header>
		<h5>第21章 Ajax 与 Comet</h5>
	</header>
	<main>
		<ol>
			<li>XMLHttpRequest对象
				<ul>
					<li>xhr的用法</li>
					<pre><code class="javascript">
					var xhr = new XMLHttpRequest();
					//三个参数：请求类型、URL、是否异步发送
					xhr.open('get','example.php',false);
					//一个参数：作为请求体发送的数据
					xhr.send(null);
					//status=304表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本
					if((xhr.status >=200 && xhr.status < 300) || xhr.status == 304){
						console.log(xhr.responseText);
					}else{
						console.log('Request was unsuccessful: ' + xhr.status);
					}
					</code></pre>
					<pre><code class="javascript">
					var xhr = new XMLHttpRequest();
					xhr.onreadystatechange = function(){
						if(xhr.readyState == 4){
							if((xhr.status >= 200 && xhr.status < 300) || xhr.stauts == 304){
								console.log(xhr.responseText);
							}else{
								console.log('Requeset was unsuccessful: ' + xhr.status);
							}
						}
					};
					xhr.open('get','example.txt',true);
					xhr.send(null);
					</code></pre>
					<pre><code class="javascript">
					xhr.abort();
					</code></pre>
					<li>HTTP头部信息
					<ol class="lower-alpha">
						<li>常规：Accept/Accept-Charset/Accept-Encoding/Accept-Language/Coonection/Cookie/Host/Referer</li>
						<li>自定义
						</li>
					</ol>
					<pre><code class="javascript">
						xhr.open('get', 'exmaple.php', true);
						//必须在调用open方法之后且调用send方法之前
						xhr.setRequestHeader('MyHeader', 'MyValue');
						xhr.send(null);

						var myHeader = xhr.getResponseHeader('MyHeader');
						var allHeaders = xhr.getAllResponseHeaders();
						</code></pre>
					</li>
					<li>GET请求：参数名和值必须编码
					<pre><code class="javascript">
					function addURLParam(url, name, value){
						url += (url.indexOf('?') == -1 ? '?' : '&');
						url += encodeURIComponent(name) + '=' + encodeURIComponent(value);
						return url;
					}
					var url = 'example.php';
					url = addURLParam(url, 'name', 'Nicholas');
					url = addURLParam(url, 'book', 'Professional Javascript');
					xhr.open('get', url, false);
					</code></pre>
					</li>
					<li>POST请求</li>
				</ul>
			</li>
			<li>XMLHttpRequest2级
			<ul>
				<li>FormData</li>
				<pre><code class="javascript">
				var data = new FormData();
				data.append('name', 'Nicholas');

				var xhr = new XMLHttpRequest();
				xhr.open('post', 'postexample.php', true);
				var form = document.getElementById('user-info');
				xhr.send(new FormData(form));
				</code></pre>
				<li>超时设定</li>
				<pre><code class="javascript">
				var xhr = new XMLHttpRequest();
				xhr.onreadystatechange = function(){
					if(xhr.readyState == 4){
						try{
							if((xhr.status >= 200 || xhr.status < 300) || xhr.status  == 304){
								console.log(xhr.responseText)
							}else{
								console.log('Request was unsuccessful: ' + xhr.status);
							}
						}catch(ex){
							//假设由ontimeout事件程序处理
						}
					}
				}
				xhr.open('get', 'timeout.php', true);
				xhr.timeout = 1000; //IE8+
				xhr.ontimeout = function(){
					console.log('Request did not return in a second.');
				};
				xhr.send(null);
				</code></pre>
				<li>overrideMimeType()方法</li>
				<pre><code class="javascript">
				var xhr = new XMLHttpRequest();
				xhr.open('get', 'text.php', true);
				xhr.overrideMimeType('text/xml');
				xhr.send(null);
				</code></pre>
			</ul>
			</li>
			<li>进度事件
			<ul>
				<li>loadstart: 在接收到响应数据的第一字节时触发。</li>
				<li>progress：在接收响应期间持续不断地触发。</li>
				<li>error：在请求发生错误时触发。</li>
				<li>abort：在因为调用abort()方法二终止连接时触发。</li>
				<li>load：在接收到完整的响应数据时触发。</li>
				<li>loadend：在通信完成或者触发error、abort、load事件后触发</li>
			</ul>
			<pre><code class="javascript">
			//在open前调用
			xhr.onprogress = function(event){
				var divStatus = document.getElementById('status');
				if(event.lengthComputable){
					divStatus.innerHTML = 'Received ' + event.position + ' of' + event.totalSize + 'bytes';
				}
			}
			</code></pre>
			</li>
			<li>跨源资源共享
			<ol class="lower-alpha">
				<li>CORS（Cross-Origin Resource Sharing，跨源资源共享）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。 基本思想是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求成功与否。 </li>
				<li>Origin 头部、Access-Control-Allow-Origin 头部</li>
				<li>请求和响应都不包含 cookie 信息</li>
			</ol>
			<ul>
				<li>IE对CORS(IE8)</li>
				<ol class="lower-alpha">
					<li>只能设置请求头部信息中的 Content-Type 字段</li>
					<li>不能访问响应头部信息</li>
					<li>只支持 GET 和 POST 请求</li>
					<li>在接收到响应后，只能访问响应的原始文本；没有办法确定响应的状态代码</li>
				</ol>
				<pre><code class="javascript">
				var xdr = new XDomianRequest();
				xdr.onload = function(){
					alert(xdr.responseText);
				}
				xdr.onerror = function(){
					alert('An error occurred');
				}
				xdr.open('get', 'http://www.somewhere-else.com/page/');
				xdr.send(null)
				</code></pre>
				<li>其他浏览器对CORS的实现(通过 XMLHttpRequest对象实现了对 CORS 的原生支持)</li>
				<li>Preflighted Reqeusts(options)</li>
				<ol class="lower-alpha">
					<li>request: Origin、Access-Control-Request-Method、Access-Control-Request-Headers</li>
					<li>response: Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers、Access-Control-Max-Age</li>
				</ol>
				<li>带凭据的请求</li>
				<ol class="lower-alpha">
					<li>通过将 withCredentials 属性设置为true，可以指定某个请求应该发送凭据</li>
					<li>服务器: Access-Control-Allow-Credentials: true</li>
				</ol>
				<pre><code class="javascript">
				let isCredentials = (function () {
				    return 'withCredentials' in new XMLHttpRequest();
				})()
				</code></pre>
				<li>跨浏览器的CORS</li>
				<pre><code class="javascript">
				function createCORSRequest(method, url){
					var xhr = new XMLHttpRequest();
					if('withCredentials' in xhr){
						xhr.open(method,url, true);
					}else if(typeof XDomainRequest !== 'undefined'){
						xhr = new XDomainRequest();
						xhr.open(method, url);
					}else{
						xhr = null;
					}
					return xhr;
				}
				var request = createCORSRequest('get', 'http://www.somewhere-else.com/page/');
				if(request){
					request.onload = function(){
						//对request.responseText进行处理
					}
					request.send(null);
				}
				</code></pre>
			</ul>
			</li>
			<li>其他跨域技术
			<ul>
				<li>图像Ping</li>
				<ol class="lower-alpha">
					<li>图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式</li>
					<li>图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数</li>
				</ol>
				<pre><code class="javascript">
				var img = new Image();
				img.onload = img.onerror = function(){
					alert('Done!');
				}
				img.src = 'http://www.example.com/test?name=Nicholas'
				</code></pre>
				<li>JSONP(JSON with padding)</li>
				<ol class="lower-alpha">
					<li>JSONP 由两部分组成：回调函数和数据</li>
					<li>回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。</li>
					<li>而数据就是传入回调函数中的 JSON 数据。</li>
					<li>其他域不安全、要确定 JSONP 请求是否失败并不容易</li>
				</ol>
				<pre><code class="javascript">
				function handleResponse(response){
					alert("You're at IP address " + response.ip + ', which is in ' + response.city + ', ' + response.region_name);
				}
				var script = document.createElement('script');
				script.src = 'http://freegeoip.net/json/?callback=handleResponse';
				document.body.insertBefore(script, document.body.firstChild);
				</code></pre>
				<li>Comet</li>
				<li>服务器发送事件</li>
				<li>Web Sockets</li>
				<li>SSE与Web Sockets</li>
			</ul>
			</li>
			<li>安全</li>
			<ol class="lower-alpha">
				<p>*对于未被授权系统有权访问某个资源的情况，我们称之为 CSRF（Cross-Site Request Forgery，跨站点请求伪造）</p>
				<li>要求以 SSL 连接来访问可以通过 XHR 请求的资源</li>
				<li>要求每一次请求都要附带经过相应算法计算得到的验证码</li>
				<p>*下列措施对防范 CSRF 攻击不起作用。</p>
				<li>要求发送 POST 而不是 GET 请求——很容易改变</li>
				<li>检查来源 URL 以确定是否可信——来源记录很容易伪造</li>
				<li>基于 cookie 信息进行验证——同样很容易伪造</li>
			</ol>
		</ol>
	</main>
	<script>
	hljs.initHighlightingOnLoad();
	</script>
</body>
</html>


     